### m<=4000000の解法
根を決めて根付き木にする  
根付き木に関する用語  
頂点vの親...頂点vから1つ根の方向に登った頂点  
頂点vの子...頂点vと直接つながる頂点のうち親以外の頂点  
頂点vの祖先...頂点vからいくつか根の方向に登った頂点  
頂点vの子孫...頂点vが祖先であるような頂点  

根からdfsをして各頂点について最初に訪れたタイミングと，その頂点を出るタイミングを記録する  
counter = 0  
dfs(station v):  
    in[v] = counter++  
    call dfs(c) for each child c of v  
    out[v] = counter++  
 
call dfs(root)  
in,outは2000未満だから頂点vのラベルとしてin[v]*2000+out[v]を用いる  
すると(ラベル)/2000,ラベル%2000でそれぞれin,outを復元できる．  
このin,outの情報を用いて次に移動する頂点を決めることができる．  
具体的には頂点vが頂点uの祖先(uから根に向かって登る途中にvがある)であるとき  
in[v]　<　in[u]　< out[u] <　out[v]が成り立つ  
よってin,outの情報からある2つの頂点が祖先と子孫の関係にあるかが分かる．  

現在の頂点と，つながっている頂点のinを比較することで現在の頂点の親と子を特定することができる．  
子を1つずつ見ていってもしその子が目的地の祖先だった場合は，次の移動先はその子と特定できる．  
もしどの子も目的地の祖先でない場合は，自分の親が次の移動先と特定できる．  

### 満点(m<=1000)解法
根からの距離が偶数の頂点についてはin,奇数の頂点についてはoutの値をラベルにする．  
これはm<=2000を満たしている．  
ある頂点vについて関数が呼ばれたとき  
vのラベルはinが書いてあり，vとつながる頂点のラベルはすべてoutである  
またはvのラベルがoutであり，vとつながる頂点のラベルはすべてinである  
のどちらかである．  
どちらのパターンだるかはラベルの大小で判定できる(inの方が小さい)  
前者のパターンの場合  
vとつながる頂点をoutの昇順にソートすると，一番最後は親で残りが子であると分かる．  
またこの子は訪れた順番になっているのでinの値が復元できる  
(一番最初に訪れた子はvの次に訪れているからin[v]+1,2番目に訪れた子は1番目の子を出た次に訪れているからout[一番目の子]+1)  
よって子のin,outが分かったのでm<=4000000の解法と同じように次に訪れる頂点を特定できる．  
後者のパターンの場合も同様  

最後にm<=1000に減らす方法について  
上のアルゴリズムはラベルの大小によってのみ決まる．  
実際にラベルに使うのは0～2000の内1000個の数のみなので，使う数のみ取り出して小さい順に番号を付けなおすとm<=1000を達成できる．  

